# Fonctions

Imaginons qu'on a pour mission de programmer un robot, qui doit se dÃ©placer dans un bÃ¢timent.

Ce robot doit ouvrir les portes.

Ouvrir une porte c'est un ensemble d'instructions.

_Algorithme_ pour que le robot ouvre une porte :
- se placer devant la porte
- poser la "main" sur la poignÃ©e
- appuyer sur la poignÃ©e
- tirer
- etc

Pour gÃ©rer un trajet du robot Ã  travers le bÃ¢timent il faudra ouvrir plusieurs portes, donc rÃ©pÃ©ter ces instructions Ã  chaque fois.

On peut copier/coller le morceau de code, Ã§a va rendre le code plus long et compliquÃ©. Il faudra se souvenir oÃ¹ commencent et se terminent les instructions pour l'ouverture d'une porte, pas oublier une instruction.

Et si plus tard on doit rajouter une instruction "prendre une photo" Ã  chaque fois qu'on vient d'ouvrir une porte, il faudra reprendre tous les endroits du code dupliquÃ© et ajouter une ligne... Sans oublier des endroits du code oÃ¹ le robot ouvrait une porte...  GalÃ¨re ğŸ˜¬

Et puis il va nous falloir un traitement pour ouvrir une porte Ã  pousser plutÃ´t que tirer, traitement presque pareil mais pas exactement... ğŸ¥µ

=> Souvent on a besoin de regrouper un ensemble d'instructions, notamment pour pouvoir rÃ©utiliser cet ensemble plusieurs fois, mais aussi pour pouvoir automatiser un traitement en le personnalisant (l'ouverture d'une porte vers l'extÃ©rieur / vers l'intÃ©rieur)

Pour Ã§a on va utiliser des **fonctions** (un principe trÃ¨s courant dans les langages de programmation, ce n'est pas spÃ©cifique Ã  JavaScript).

Une **fonction** : un traitement (un ensemble d'instructions) qu'on peut appliquer plusieurs fois. Ce traitement porte un nom, pour pouvoir l'appliquer facilement.

## Syntaxe

- dÃ©finir une fonction : **dÃ©claration** d'une fonction, mise en place d'un traitement qu'on pourra ensuite utiliser

![](./schemas/function_declaration.png)

Les instructions sont appelÃ©es _corps_ de la fonction.

- appliquer le code d'une fonction qu'on a dÃ©finie : exÃ©cution (ou appel) de la fonction

![](./schemas/function_execution.png)

Une fonction a UNE dÃ©claration (qui ne produit pas de rÃ©sultat), et autant d'exÃ©cutions qu'on souhaite.

### Nommer une fonction

- sans espaces, sans points, sans tirets - (underscore _ c'est possible)
- indique ce que fait la fonction (commence souvent par un verbe)
- de prÃ©fÃ©rence en anglais
- en camelCase, en commenÃ§ant par une minuscule https://fr.wikipedia.org/wiki/Camel_case
- unique (pas d'autre fonction ou de variable qui porte le mÃªme nom, et ne pas utiliser les mots-clÃ©s du langage)

Exemples : `sayHello`, `displayResultWithColors`, `checkAnswer`

### Premier exemple de fonction (sans paramÃ¨tres/arguments)

```js
function sayHello() {
  alert("Hello");
}
```
=> on a dÃ©clarÃ© un traitement (un ensemble d'instructions) pour dire bonjour, on lui a donnÃ© le nom "sayHello" pour pouvoir l'utiliser plus tard

En faisant cette dÃ©claration, aucune alerte ne s'affiche.

```js
sayHello();
```

=> un alert s'affiche


```js
sayHello();
sayHello();
sayHello();
```

=> 3 alert s'affichent

### ParamÃ¨tres et arguments

Pour personnaliser le traitement, on peut mettre en place un/des _paramÃ¨tre(s)_.

C'est quand le traitement fait presque toujours pareil, mais avec une information dynamique par exemple, ou avec un comportement lÃ©gÃ¨rement adaptable.

Exemple : on veut dire bonjour en citant le prÃ©nom de la personne. On ne va pas crÃ©er une fonction pour chaque prÃ©nom : sayHelloJohn, sayHelloMarie ... ğŸ˜†

On va plutÃ´t indiquer que la fonction pour dire bonjour utilise une information qui reprÃ©sente un prÃ©nom :

```js
function sayHello(name) {
    alert("Hello " + name);
}
```

On choisit le nom qu'on veut pour les paramÃ¨tres, avec les mÃªmes contraintes de nommage que pour les variables. S'il y a plusieurs paramÃ¨tres, on les sÃ©pare avec des virgules.

```js
function sayHelloCompleteName(firstName, lastName) {
    // ici firstName et lastName sont les paramÃ¨tres de la fonction
    alert("Hello " + firstName + " " + lastName);
}
```

Pour l'exÃ©cution des fonctions on fournit une valeur pour chacun des paramÃ¨tres, dans le mÃªme ordre que les paramÃ¨tres ont Ã©tÃ© dÃ©finis. On appelle ces valeurs des arguments.

Exemple avec un seul paramÃ¨tre :

```js
// on dÃ©finit une fonction pour dire bonjour en citant un prÃ©nom
// ici name est une information nÃ©cessaire Ã  la fonction pour appliquer le traitement : un paramÃ¨tre
function sayHello(name) {
    alert('Hello ' + name);
}

// on applique le traitement contenu dans la fonction, en fournissant une information que la
// fonction utilisera pour son traitement
// si la fonction a un ou des paramÃ¨tres, il faut fournir au moment de l'exÃ©cution les valeurs pour chacun des paramÃ¨tres : on appelle ces valeurs des arguments
sayHello('Mathieu');
sayHello('Tserisoa');

// si on oublie de fournir un argument, sa valeur sera undefined (valeur spÃ©ciale en JS qui indique que quelque chose n'a pas de valeur)
sayHello(); // Hello undefined
```

Exemple avec deux paramÃ¨tres :

```js
// on dÃ©finit une fonction pour dire bonjour en citant un prÃ©nom
// ici firstName et lastName sont des informations nÃ©cessaires Ã  la fonction pour appliquer le traitement : des paramÃ¨tres
function sayHello(firstName, lastName) {
    alert('Hello ' + firstName + ' ' + lastName);
}

// on applique le traitement contenu dans la fonction
// si la fonction a un ou des paramÃ¨tres, il faut fournir au moment de l'exÃ©cution les valeurs pour chacun des paramÃ¨tres : on appelle ces valeurs des arguments
sayHello('Harry', 'Potter');

// on peut dire bonjour Ã  qui on veut
sayHello('Hermione', 'Granger');
```

Les paramÃ¨tres peuvent Ãªtre de diffÃ©rents types (respecter les types pour les valeurs des arguments) :

```js
// dÃ©claration
function sayHelloWithAge(name, age) {
    alert("Hello " + name + " qui a " + age + " ans");
}

// exÃ©cution
sayHelloWithAge("John", 45);
// Hello John qui a 45 ans
sayHelloWithAge("Marie", 61);
// Hello Marie qui a 61 ans

// /!\ code pas pertinent
sayHelloWithAge(61, "Marie");
// Hello 61 qui a Marie ans
```

### Remarque

En fait, on utilisait dÃ©jÃ  des fonctions : `alert("Hello")` => on appelle la fonction _alert_ avec "Hello" en argument.

On n'a pas Ã©crit la dÃ©finition (dÃ©claration) de _alert_, Ã§a fait partie des outils JS.

Pour le cas de `console.log`, c'est aussi une fonction qui fait partie des outils de JS, qui s'appelle `log` et qui est rangÃ©e dans un "conteneur" (module, Ã  voir plus tard) qui s'appelle `console`.

### _return_ pour retourner un rÃ©sultat

2 types de traitements :
- _faire_ quelque chose : ouvrir une porte, afficher un message...
- _produire quelque chose_ : fabriquer un hamburger, obtenir le rÃ©sultat d'un calcul => on obtient quelque chose Ã  la fin

Faire quelque chose, dÃ©jÃ  vu :

```js
function sayHello(name) {
    console.log("Hello " + name);
}
```

Construire quelque chose : une chaÃ®ne de caractÃ¨res qui dÃ©crit un hamburger

```js
function makeHamburger(cheese) {
    const result = "pain | " + cheese + " | steak | pain";
    console.log("dans la fonction on a produit : " + result);
}
 
const hamburger = makeHamburger("comtÃ©");
console.log("AprÃ¨s l'appel Ã  la fonction on rÃ©cupÃ¨re : " + hamburger);

// on essaie d'utiliser la variable qui est crÃ©Ã©e dans la fonction
console.log(result);
// erreur "result is not defined"
```

Affichage dans la console :
> dans la fonction on a produit : pain | comtÃ© | steak | pain
> 
> AprÃ¨s l'appel Ã  la fonction on rÃ©cupÃ¨re : undefined

ğŸ’­ En JavaScript, quand on crÃ©e une variable dans une fonction, cette variable n'est pas accessible Ã  l'extÃ©rieur de la fonction (portÃ©e de let/const : un bloc de code, les `{ }`).

Notre hamburger est restÃ© dans la cuisine, euh dans la fonction ğŸ˜œ .

On demande Ã  la fonction de "faire sortir" le hamburger, avec le mot-clÃ© `return` suivi de la valeur Ã  retourner

```js
function makeHamburger(cheese) {
    const result = "pain | " + cheese + " | steak | pain";
    console.log("dans la fonction on a construit : " + result);

    // on "fait sortir" le rÃ©sultat qu'on a produit
    return result;
    // => on retourne la valeur contenue dans la variable

    // on aurait aussi pu retourner directement le hamburger
    // return "pain | " + cheese + " | steak | pain"
}

// on rÃ©cupÃ¨re le rÃ©sultat pour s'en servir
const hamburger = makeHamburger('raclette');
console.log("Hamburger pour midi : " + hamburger);

// on peut aussi se servir directement du rÃ©sultat produit par une fonction
console.log("On va aller manger ce hamburger : " + makeHamburger('raclette'));

// code inutile, on ne peut pas utiliser le hamburger
makeHamburger('camembert');
```

Note : l'application de _return_ arrÃªte le traitement de la fonction, des instructions qui seraient placÃ©es aprÃ¨s ne seront pas appliquÃ©es

```js
function makeHamburger(cheese) {
    const result = "pain | " + cheese + " | steak | pain";

    // on retourne la valeur de la variable
    return result;

    // le code ici ne sera jamais appliquÃ©
    console.log("jamais affichÃ©");
}
```

On ne peut pas retourner plusieurs choses dans une fonction, sauf si on ruse, par exemple en rangeant dans un tableau et en retournant le tableau.

Pour aller plus loin : il peut y avoir plusieurs instructions return dans une fonction, mais elles ne doivent pas s'appliquer dans le mÃªme cas :

```js
function getPrice(age) {
    if (age < 3) {
        return 0;
    } else {
        return 75;
    }
}

const price = getPrice(25);
console.log(price); // 75

const priceChild = getPrice(2);
console.log(priceChild); // 0
```

Si une fonction n'a pas de return et qu'on essaie de rÃ©cupÃ©rer son rÃ©sultat dans une variable, la variable vaudra _undefined_.

## Valeur par dÃ©faut pour un paramÃ¨tre de fonction

Quand on appelle une fonction, si on ne fournit pas de valeur pour l'un des paramÃ¨tres, alors il vaudra _undefined_. On peut indiquer une valeur par dÃ©faut pour un paramÃ¨tre, c'est-Ã -dire une valeur qui sera utilisÃ©e automatiquement pour ce paramÃ¨tre s'il n'a pas de valeur fournie.



```js
function makeHamburger(cheese) {
    const hamburger = "pain | " + cheese + " | steak | pain";


    // on "fait sortir" le rÃ©sultat, on le retourne
    return hamburger;
}

const hamburger = makeHamburger();
// On n'a pas indiquÃ© quel fromage on veut
console.log(hamburger);
// pain | undefined | steak | pain
```

Si on veut que le fromage soit du comtÃ© pour le hamburger de base, et pouvoir prÃ©ciser un autre fromage si on veut : on va indiquer _comtÃ©_ comme valeur par dÃ©faut pour le paramÃ¨tre _cheese_ 

```js
function makeHamburger(cheese = "comtÃ©") {
    // si la valeur pour cheese n'a pas Ã©tÃ© indiquÃ©e lors de l'appel de la fonction, alors dans le corps de la fonction cheese vaut "comtÃ©" 

    const hamburger = "pain | " + cheese + " | steak | pain";


    // on "fait sortir" le rÃ©sultat, on le retourne
    return hamburger;
}

// hamburger basique, automatiquement au comtÃ©
const hamburgerBasique = makeHamburger();
console.log(hamburgerBasique);
// pain | comtÃ© | steak | pain

// hamburger personnalisÃ©, on choisit le fromage
const hamburgerRaclette = makeHamburger('raclette');
console.log(hamburgerRaclette);
// pain | raclette | steak | pain
```

Si on tente d'ajouter un deuxiÃ¨me paramÃ¨tre pour pouvoir choisir le pain

```js
function makeHamburger(cheese = 'comtÃ©', bread) {
    // on produit un hamburger
    const result = bread + " | " + cheese + " | steak | " + bread;

    // et on le "fait sortir" pour l'utiliser en-dehors de la fonction
    return result;
}
 
// code pas correct : on obtient un hamburger avec juste du pain briochÃ© et du steak
const hamburgerBasique = makeHamburger('pain briochÃ©');
console.log(hamburgerBasique);
// undefined | pain briochÃ© | steak | undefined

const hamburgerRaclette = makeHamburger('raclette', 'pain brasserie');
console.log(hamburgerRaclette);
```

On fait en sorte que le pain soit bien le deuxiÃ¨me argument :

```js
const hamburgerBasique = makeHamburger(undefined, 'pain briochÃ©');
console.log(hamburgerBasique);
// pain briochÃ© | comtÃ© | steak | pain briochÃ©
```

Pas trÃ¨s pratique de devoir injecter undefined comme argument => gÃ©nÃ©ralement on place en dernier les paramÃ¨tres qui ont une valeur par dÃ©faut

```js
// si aucune valeur n'est fournie pour le paramÃ¨tre cheese, alors on utilise la valeur "comtÃ©"
function makeHamburger(bread, cheese = 'comtÃ©') {
    // on produit un hamburger
    const result = bread + " | " + cheese + " | steak | " + bread;

    // et on le "fait sortir" pour l'utiliser en-dehors de la fonction
    return result;
}
 
// hamburger basique, automatiquement au comtÃ©
const hamburgerBasique = makeHamburger('pain briochÃ©');
console.log(hamburgerBasique);

// hamburger personnalisÃ©, on choisit le fromage
const hamburgerRaclette = makeHamburger('pain brasserie', 'raclette');
console.log(hamburgerRaclette);
```

## fonction flÃ©chÃ©es

C'est une autre syntaxe pour les fonctions (plus moderne : ES6).

### fonction anonyme

```js
function(item) {
  return item * 2;
}
```

En flÃ©chÃ©e : on enlÃ¨ve le mot "function" et ajouter une => entre les paramÃ¨tres et le corps de la fonction

```js
(item) => {
  return item * 2;
}
```

### fonction nommÃ©e

```js
function multiplyBy2(item) {
  return item * 2;
}
```

```js
// dÃ©claration d'une fonction en utilisant la syntaxe "fonction flÃ©chÃ©e" 
const multiplyBy2 = (item) => {
  return item * 2;
}
// => multiplyBy2 c'est une variable qui contient la dÃ©finition d'une fonction
```

Pour appeler la fonction :

```js
multiplyBy2(4);
```

## Raccourcis

On peut Ã©crire n'importe quelle dÃ©finition sous forme de flÃ©chÃ©e, et on peut parfois Ã©crire "en plus court", notamment :

- si un seul paramÃ¨tre, on peut ne pas mettre de parenthÃ¨ses

```js
const multiplyBy2 = item => {
  return item * 2;
}
```

- si la seule instruction est un return, on peut faire un "return implicite" (la fonction retourne quelque chose sans qu'on Ã©crive le mot return) : enlever le mot return et les accolades

```js
// dÃ©claration de fonction
const multiplyBy2 = item => item * 2;

// utilisation de la fonction
const result = multiplyBy2(4); // 8
```

/!\ ne pas abuser de ce return implicite

```js
const sayHello = (name) => console.log('Hello ' +  name);
```

Si on appelle `sayHello('MÃ©lanie');` Ã§a applique bien le traitement. Mais dans d'autres cas (avancÃ©s) Ã§a pourrait Ãªtre source de bugs, parce que lÃ  c'est comme si on avait Ã©crit :

```js
function sayHello(name) {
    return console.log('Hello ' +  name);
}
// on retourne undefined, pas trÃ¨s utile
```



